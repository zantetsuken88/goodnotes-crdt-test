# GoodNotes - CRDT Graph Challenge

Hi, I'm Lee Stewart and welcome to my solution to the GoodNotes tech test. I'll attempt to outline how I've addressed 
each of the requirements below.

#### To get started, simply download and run the tests from two test classes located in `src/test/[...]/service/`. At the time of submission, all tests are passing in both classes on both Windows/Mac  with OpenJDK 17. If this is not the case when you are trying to run it, please do let me know as it's unexpected!

---
**Note**

As a personal preference, in my code I refer to vertices as "nodes" as this makes it easier for me to visualise the structure of the graph. Additionally, despite my apparent compulsion to write in the first-person-plural, all the code and documentation has been written by me and only me. (except for the references quoted in this document and any code generated by maven/spring packages for ease of project setup.)

---

## A brief tour of the project:
- I used IntelliJ to generate a springboot starter template project using a maven compiler.
- The project compiles and will run from the main method, although not much will happen if you do. All the concepts are demonstrated via tests.
- At `controller/ConvergeStateController` I put together the outline of an API controller for sharing state among replicas but in order to work, I imagine we'd need to add some JSON parsing capabilities etc.
- `helpers/FixedIdGenerator` is an extension of the springboot IdGenerator class which allows us to generate predictable UUIDs based on the the node's label. Theoretically I could have skipped UUIDS altogether in this implementation however if they became necessary at a "later date", I wanted to be prepared to handle them which would likely mean removing this class in favour of real UUIDs at the expense of convenience/efficiency of searching for individual nodes by their content.
- The `model` package contains the following:
  - `Edge` represents an edge in the graph, denoted by the two labels of the nodes and a timestamp.
  - `Node` class representing a Node in the Graph with a UUID, label and timestamp.
  - `ReadOnlyGraph` is explained further below. The class contains the data output once all union operations are resolved.
  - `State` is also explained below, it contains the full state to be shared between replicas.
  - `VisitedNode` is an object class used to track the distance travelled and parent nodes when traversing the graph.
- `service/ConvergeStateService` is a service class acting as the intermediary between the controller and operations pertaining to merging and communicating state between replicas.
- `service/GraphService` is the service holding the main logic for performing write operations on the local state. Here is where we can add/remove edges and nodes, and where the output graph is calculated.
- `src/test/[...]/service` contains the two test classes which assert the logic outlined below. At the time of submission - all tests in both classes are passing.

## Graph Deliverables:
There are essentially two types of graph implemented in this solution:

- The `State` class represents a graph as it is defined in terms of a CRDT. To quote the Shapiro, Preguica and Zawirski study linked [here](https://hal.inria.fr/inria-00555588/PDF/techreport.pdf) and documented [here](https://github.com/pfrazee/crdt_notes):
> A graph is a pair of sets (V,E) (called vertices and edges respectively) such that E ⊆ V × V.

In order to satisfy the deliverable of a "Last Write Wins" approach to merging replicas, we must base our sets on the LWW-element-set which in turn is a variant on the 2P-set.

> An alternative LWW-based approach, which we call LWW-element-Set, attaches a timestamp to each element (rather than to the whole set). Consider add-set A and remove-set R, each containing (element, timestamp) pairs.

As such, combining these two approaches leads to my solution - the LWW-element-graph, a LWW implementation based on the below-quoted 2P2P-Graph

> A 2P2P-Graph is the combination of two 2P-Sets; as we showed, the dependencies between them are resolved by causal delivery. Dependencies between addEdge and removeEdge, and between addVertex and removeVertex are resolved as in 2P-Set. Therefore, this construct is a CRDT.

Looking at the `State` class, you will see 2 pairs of sets, one each for adds and removals of vertices and edges respectively.

When the `State` class performs a union of these 2 pairs of sets, the results are merged and returned as a `ReadOnlyGraph`:
- The `ReadOnlyGraph` class represents a graph as a typical adjacency list. This implementation is unweighted, and undirected - however the use of classes to represent both nodes and edges allows for scalability to introduce these concepts.

As suggested by the class name, we do not perform operations directly on the `ReadOnlyGraph` - this graph is produced on the fly as a union of the existing `State` as held by the replica. 

The brief outlines the following deliverables which have been addressed by my solution:

- Add a vertex/edge
  - We perform these actions on the `State` via `GraphService:53`.
  - This is tested on `GraphServiceTest:59`.
- Remove a vertex/edge
  - Performed on the `State` via function at `GraphService:76`
  - Tested at `GraphServiceTest:113`
- Check if a vertex is in the graph
  - We are interested in the actual result here, so we check at `ReadOnlyGraph:23`.
  - There's an additional function (not requested) to check for the existence of an edge at `ReadOnlyGraph:27`
  - These functions are used as assertions across `GraphServiceTest` and alongside null-check assertions in the above add/remove tests.
- Query for all vertices connected to a vertex
  - A method is provided at `ReadOnlyGraph:35` - the adjacency list structure makes this quite simple to implement since each node is mapped to a list of connected nodes.
  - This is tested at `GraphServiceTest:104`
- Find any path between two vertices
  - I went a step further here and implemented a _shortest_ path function at `ReadOnlyGraph:39`.
  - This is tested at `GraphServiceTest:199`
- Merge with concurrent changes from other graph/replica
  - This is covered in more detail below.

## CRDT Deliverables:

The `GraphService` class performs operations on the local `State` such as the structure operates as a state-based CRDT. In order to ensure that this is the case, we check against the following criteria:

> In State based replication, updates contain the full object state.

`ConvergeStateService` acts as the intermediary controller service between replicas. In this implementation, the bare bones of a rest API has been outlined (but is not fully functional, nor necessarily the correct way to communicate between replicas - investigating this was beyond the scope of the test). The intent should be clear however, that referring to:
- `ConvergeStateService:15` an incoming GET request will fetch and return the entire state of the local replica.
- `ConvergeStateService:23` contains the merge function (detailed below) which will receive a state fetched from a remote replica and merge it with the local state.

> A state-based CRDT (CvRDT) must...
> Have a partial order to the values.

In this implementation the timestamp attached to each value (nodes *and* edges) implies total order. 

> "Monotonically increase" in state, meaning a new state only ever succeeds the current state in the value's ordering.

The union of the replicas takes place on a "last write wins" basis meaning that the state cannot revert to an earlier version. The union will always favour the later timestamp.

> Define a merge function ("least upper bound") which is idempotent and order-independent.

At `ConvergeStateService:23` - we find a merge function which directs the received state to `GraphService:86`. We then find separate functions to merge nodes and edges at lines 169 and 179 respectively.
- At `ConvergeStateServiceTest:86` I have written a detailed testing strategy which checks for independence of order and idempotency. 
- In short: by the time the local state receives updates from all 3 replicas, it will have received replica A's update 3 times. Once directly from replica A, and once each via replicas B and C which both merged in A's update prior to performing their operations. The presence of a timestamp on each element preserves idempotency since the timestamp will not change after the operation is first performed. The only way to supersede this operation would be to perform a new operation on the same element with a newer timestamp. The same fact also guards against unwanted outcomes from state updates merged out of chronological sequence.

> An element e is in the set if it is in A, and it is not in R with a higher timestamp

At `GraphService:101` begins two methods for providing the union of the nodes and edges in the current state. In both cases, we start by collecting all elements that are in the add set, but not in the remove set. Then, for those contained in both sets we filter, retaining only elements which are in the add set with a timestamp *after* the same element's timestamp in the remove set.
- We test this on several occasions - explicitly this is tested in `GraphServiceTest:161` by asserting the node is not considered present after removal (it is added to the remove set with a higher timestamp) and then by asserting it *is* considered present when newly added to the add set with a yet-higher timestamp.

> What should happen upon concurrent addEdge(u,v) || removeVertex(u)? We see three possibilities: (i) Give precedence to removeVertex(u): all edges to or from u are removed as a side effect.

We favour removals in the final graph - that is - an element must be in the add set *after* the timestamp in the remove set to be considered present. Therefore, equal timestamps will result in the remove set's favour.
When it comes to resolving the existence of edges, when assembling the `ReadOnlyGraph` at `GraphService:23`: we loop through the union of the node sets and add them to the Map with a list of their connected nodes *only* if their connected nodes are present in the node set. As such, we cannot consider an edge to be present if the supporting nodes are not also present - but importantly we do not obstruct the addition of edges to the add edge set since to do so may inhibit an out of sequence state merge which attempts to add the edge before the update adding the nodes has been received.
- We test that our graph favours vertex removal in `ConvergeStateServiceTest:207`. On lines 220 and 221, concurrent operations take place on local and replica states which both remove a node, and attempt to add an edge to the same node. We assert that the node is not present, and all edges associated to that node are not present, including the ones which were added concurrently. 
